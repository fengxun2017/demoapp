#!/bin/bash
set -e

function report_error_and_exit {
    echo "Insufficient or invalid arguments"
    echo "To clean try build.sh clean"
    echo "Build try build.sh  target"
    exit -1
}

# Validate mandatory arguments
if [ -z "$1" ]
then
    report_error_and_exit
fi

for i in "$@"
do
case $i in
    clean)
    CLEAN="true"
    shift # past clean
    ;;
    build_type=*)
    BUILD_TYPE="${i#*=}"
    shift # past build_type=value
    ;;
    target)
    BUILD="target"
    shift # past target
    ;;
    code_gen=*)
    CODE_GEN="${i#*=}"
    shift # past code_gen=value
    ;;
    -j|--jobs)
    PARALLEL_MAKE="$i"
    shift
    # check whether the next argument is a number (not strict though)
    case "$1" in
        [1-9]*) # not strict indeed
        PARALLEL_MAKE="$PARALLEL_MAKE $1"
        ;;
        *) # impose a reasonable job number limit
        # see https://stackoverflow.com/questions/10898528/how-can-i-tell-what-j-option-was-provided-to-make
        NJOBS=$(grep -c processor /proc/cpuinfo 2>/dev/null || echo 1)
        PARALLEL_MAKE="$PARALLEL_MAKE $NJOBS"
        ;;
    esac
    ;;
    *)
    shift # unknown option
    ;;
esac
done

# Validate or set default build type
if [[ "$BUILD_TYPE" != "DEBUG" && "$BUILD_TYPE" != "RELEASE" ]]; then
    echo "BUILD_TYPE is not specified. Set to DEBUG by default"
    BUILD_TYPE="DEBUG"
fi

SCRIPT_DIR=$(cd $(dirname $0) && pwd)
echo "SCRIPT_DIR="$SCRIPT_DIR


# #Restore base directory and show where found
# echo "PROJ_DIR="$PROJ_DIR
# if [ -n "$PROJ_DIR" ]; then
#     cd "$PROJ_DIR"
# fi

# Check the operation that has been requested
if [[ ${CLEAN} == "true" ]]
then
    cmake -DSTRICT_PATH_CHECK=0 -Bbuild/${BUILD_TYPE} -H.
    make -Cbuild/${BUILD_TYPE} clean --no-print-directory
    make -Cbuild/${BUILD_TYPE} code_gen_clean --no-print-directory
else

    # Check whether a request to suppress code generation has been made
    if [[ ${CODE_GEN} != "off" ]]; then
        echo "clear old data"
        make distclean
        cur_dir=$(pwd)
        echo "start cmake, cur_dir="$cur_dir
        # The first run of CMake is to create build targets for code generators
        cmake  -DBUILD_TYPE=${BUILD_TYPE} -DSTRICT_PATH_CHECK=0 -Bbuild/${BUILD_TYPE}  -H.
        # Clean all code generators
        make $PARALLEL_MAKE -Cbuild/${BUILD_TYPE} code_gen_clean --no-print-directory
        # Run all code generators
        make $PARALLEL_MAKE -Cbuild/${BUILD_TYPE} code_gen --no-print-directory

        echo "Code Gen Complete"
    else
        echo "Code Gen is set off"
    fi

    # The second run of CMake processes all the files generated by the code generators
    cmake  -DBUILD_TYPE=${BUILD_TYPE} -DSTRICT_PATH_CHECK=1 -Bbuild/${BUILD_TYPE}  -H.
    make $PARALLEL_MAKE -Cbuild/${BUILD_TYPE} --no-print-directory

fi
